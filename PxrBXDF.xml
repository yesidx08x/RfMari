<Node>
/* (c)2016 Yang Yongtao Based on Pixar RenderMan - PxrLMLayer.\nThis is a Custom Standalone Shader  for MARI written in OpenGL Shading Language Modify From Antonio Lisboa M. Neto">PxrBXDF,PxrRMS for maya R20 */
 
  <ID>PxrBXDF</ID>
  <Inputs>	
    <Input Name="DiffuseColor" 	    	PrettyName="Diffuse Color"						></Input>
    <Input Name="DiffuseSheen" 	    	PrettyName="Diffuse Sheen"						></Input>
	<Input Name="Opacity_Map" 	    	PrettyName="Opacity Map"						></Input>
	<Input Name="DiffuseRoughness"  	PrettyName="Diffuse Roughness"					></Input>
	<Input Name="Incandescence" 	PrettyName="Incandescence"					></Input>
	<Input Name="SpecularColor"     	PrettyName="Specular Color"					></Input>
	<Input Name="HighlightGlossiness" 	PrettyName="Highlight Glossiness"				></Input>
    <Input Name="ReflectionGlossiness" 	PrettyName="Reflection Glossiness"				></Input>
	<Input Name="Anisotropy" 			PrettyName="Anisotropy"							></Input>	
	<Input Name="Vector" 				PrettyName="Anisotropy UV Coords"				></Input>
	<Input Name="Rotation" 				PrettyName="Rotation"							></Input>	
	<Input Name="RefractionColor"		PrettyName="Refraction Color"					></Input>
    <Input Name="RefractionGlossiness"	PrettyName="Refraction Glossiness" 				></Input>
	<Input Name="Fog_Color"				PrettyName="Fog Color"							></Input>
	<Input Name="Translucency_Color"    PrettyName="Translucency Color"					></Input>	
	<Input Name="Bump"					PrettyName="Bump Map"							></Input>
    <Input Name="Normal"				PrettyName="Normal Map"							></Input>
	<Input Name="Displacement"			PrettyName="Displacement Map"					></Input>
	<Input Name="ThicknessMap" 			PrettyName="Thickness Map"						></Input>	
	<Input Name="View_Current_Channel" 	PreferredInput='1'></Input>
  </Inputs>
  <Attributes>
	<Attribute Name="shadingNode" 					PrettyName="Type"										Group="" 						Type="stringlist" 	Description="(c)2016 Yang Yongtao Based on Pixar RenderMan - PxrLMLayer.\nThis is a Custom Standalone Shader  for MARI written in OpenGL Shading Language Modify From Antonio Lisboa M. Neto">PxrBXDF,PxrRMS for maya R20</Attribute>	
	<!--=============================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================-->
	<Attribute Name="DiffuseColor" 					PrettyName="Diffuse Color"								Group="Basic Parameters"		Type="color" 		Description="">(0.5,0.5,0.5,1)</Attribute>
	<Attribute Name="DiffuseSheen" 					PrettyName="Diffuse Sheen"								Group="Basic Parameters"		Type="color" 		Description="">(0.0,0.0,0.0,1)</Attribute>
	<Attribute Name="DiffuseAmount" 				PrettyName="Diffuse Amount"								Group="Basic Parameters"		Type="double"		Description="This is a multiplier for the Diffuse Color." Min="0" Max="1">1.0</Attribute>
	<Attribute Name="Opacity_Map"					PrettyName="Opacity Map"								Group="Basic Parameters"		Type="color" 		Description="">(1,1,1,1)</Attribute>
	<Attribute Name="DiffuseRoughness" 				PrettyName="Roughness"							Group="Basic Parameters"		Type="double"		Description="This parameter can be used to simulate rough surfaces or surfaces covered with dust." Min="0" Max="1">0.0</Attribute>
	<Attribute Name="Incandescence" 			PrettyName="Incandescence"							Group="Basic Parameters"		Type="color" 		Description="">(0,0,0,1)</Attribute>
	<!--=============================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================-->
	<!--<Attribute Name="BRDF_Model" 					PrettyName="BRDF"    									Group="Reflection"				Type="stringlist" 	Description="The BRDF parameters determine the type of the highlights and glossy reflections for the material.">Blinn,Phong,Blinn,Ward,GGX</Attribute>-->
	<Attribute Name="SpecularColor"   			PrettyName="Specular Color"							Group="Reflection"				Type="color" 		Description="">(0,0,0,1)</Attribute>
	<Attribute Name="ReflectionAmount"				PrettyName="Reflection Amount"							Group="Reflection"				Type="double"		Description="This is a multiplier for the Reflection Color."	Min="0" Max="1">1.0</Attribute>
	<Attribute Name="Lock_Highlight_Refle_gloss" 	PrettyName="Lock highlight and reflection glossiness"	Group="Reflection" 				Type="bool"			Description="When this option is off you can enter different values for the Hilight glossiness and Reflection glossiness.\nHowever this will not produce physically correct results.">true</Attribute>
	<Attribute Name="HighlightGlossiness" 			PrettyName="Highlight Glossiness"						Group="Reflection"				Type="double" 		Description="This determines the shape of the highlight on the material.\nNormally this parameter is locked to the Reflection glossiness value in order to produce physically accurate results." Min="0" Max="1">1.0</Attribute>	
	<Attribute Name="ReflectionGlossiness" 			PrettyName="Reflection Glossiness"						Group="Reflection"				Type="double" 		Description="Controls the sharpness of reflections.\nA value of 1.0 means perfect mirror-like reflection;\nlower values produce blurry or glossy reflections." Min="0" Max="1">1.0</Attribute>
	<!--
	<Attribute Name="Fresnel_On"					PrettyName="Use Fresnel" 								Group="Reflection"				Type="bool"			Description="Checking this option makes the reflection strength dependent on the viewing angle of the surface.\nSome materials in nature (glass etc) reflect light in this manner. Note that the Fresnel effect depends on the index of refraction as well.">true</Attribute>
	<Attribute Name="Fresnel_useIOR"				PrettyName="Lock Fresnel IOR to Refraction IOR"			Group="Reflection"				Type="bool"	 		Description="Allows you to unlock the Fresnel IOR parameter for finer control over the reflections.">true</Attribute>
	
	<Attribute Name="Refractive_Index" 				PrettyName="Refractive Index"								Group="Reflection"				Type="double" 		Description="The IOR to use when calculating Fresnel reflections.\nNormally this is locked to the Refraction IOR parameter, but you can unlock it for finer control." Min="0" Max="10">1.6</Attribute>
  <Attribute Name="ggxTailFalloff"				PrettyName="GGX Tail falloff"							Group="Reflection"				Type="double"  		Description="Determines the highlight tail falloff for the GGX BRDF Specular Model." Min="2" Max="10">2.0</Attribute>-->
	<!--=============================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================-->
	<Attribute Name="Anisotropy" 					PrettyName="Anisotropy"									Group="Anisotropy"				Type="double"  		Description="Determines the shape of the highlight. A value of 0.0 means isotropic highlights.\nNegative and positive values simulate 'brushed' surfaces." Min="-1.0" Max="1.0">0.0</Attribute>
	<Attribute Name="Rotation" 						PrettyName="Anisotropy Rotation"						Group="Anisotropy"				Type="double"  		Description="Determines the orientation of the anisotropic effect in degrees (rotation in degrees)." Min="0" Max="1">0.0</Attribute>
	<!--=============================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================-->
	<Attribute Name="RefractionColor"				PrettyName="Refraction Color"							Group="Refraction"				Type="color" 		Description="">(0,0,0,1)</Attribute>
	<Attribute Name="RefractionAmount"				PrettyName="Refraction Amount"							Group="Refraction"				Type="double" 		Description="This is the amount of the refraction color.\n*Note, Refraction is not displayed correctly in the OrthoView, and it's not fully supported in Mari." Min="0" Max="1">1.0</Attribute>
	<Attribute Name="RefractionGlossiness" 			PrettyName="Refraction Glossiness"						Group="Refraction"				Type="double" 		Description="Controls the sharpness of refractions. A value of 1.0 means perfect glass-like refraction;\nlower values produce blurry or glossy refractions." Min="0" Max="1">1.0</Attribute>
	<Attribute Name="IOR"							PrettyName="Refraction IOR"								Group="Refraction"				Type="double" 		Description="Index of refraction for the material, which describes the way light bends when crossing the material surface.\nA value of 1.0 means the light will not change direction." Min="0" Max="10">1.6</Attribute>
	<Attribute Name="Fog_Color"						PrettyName="Fog Color"									Group="Refraction"				Type="color" 		Description="">(1,1,1,1)</Attribute>
	<Attribute Name="Fog_multiplier" 				PrettyName="Fog multiplier"								Group="Refraction"				Type="double"		Description="The strength of the fog effect. Smaller values reduce the effect of the fog, making the material more transparent.\nLarger values increase the fog effect, making the material more opaque." Min="0" Max="10">1.0</Attribute>
	<Attribute Name="Fog_bias" 						PrettyName="Fog bias"									Group="Refraction"				Type="double"		Description="This parameter allows to change the way the fog color is applied;\nby adjusting this parameter you can make thin parts of the object to appear more transparent than normal, or less transparent than normal." Min="-3.0" Max="3.0">0.0</Attribute>
	<!--=============================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================-->
	<Attribute Name="SSS_On"						PrettyName="On" 										Group="Subsurface scattering"	Type="bool"			Description="Enables sub-surface scattering for the material.">false</Attribute>
	<Attribute Name="Translucency_Color"			PrettyName="Translucency Color"							Group="Subsurface scattering"	Type="color" 		Description="">(1,1,1,1)</Attribute>
	<Attribute Name="Fwd_back_coeff" 				PrettyName="Fwd/back coeff"								Group="Subsurface scattering"	Type="double"		Description="Controls the direction of scattering for a ray.\n0.0 means a ray can only go forward (away from the surface, inside the object);\n0.5 means that a ray has an equal chance of going forward or backward;\n1.0 means a ray will be scattered backward (towards the surface, to the outside of the object)." Min="0" Max="1">1.0</Attribute>
	<Attribute Name="Scatt_coeff" 					PrettyName="Scattering coefficient"						Group="Subsurface scattering"	Type="double"		Description="The amount of scattering inside the object.\n0.0 means rays will be scattered in all directions;\n1.0 means a ray cannot change its direction inside the sub-surface volume." Min="0" Max="1">0.0</Attribute>
	<!--=============================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================-->
	<Attribute Name=""								PrettyName="" 											Group="Bump" 					Type="" 			Description="This is used just for hold the Bump Group in a more  appropriate place in the attributes list. This feature not allow you to update Mari Shader on fly in case of you change something here. If you wants to update reload the files from Shader Console and assign a new shader for you geometry to see the updates made on this Shader."></Attribute>
	<Attribute Name=""								PrettyName="" 											Group="Displacement" 			Type="" 			Description="This is used just for hold the Displacement Group in a more appropriate place in the attributes list. This feature not allow you to update Mari Shader on fly in case of you change something here. If you wants to update reload the files from Shader Console and assign a new shader for you geometry to see the updates made on this Shader"></Attribute>
	<!--=============================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================-->
	<Attribute Name="Light_Falloff"					PrettyName="Light Falloff"								Group="'Display Features'" 		Type="stringlist"	Description="Add falloff to Mari's Point Lights. In V-ray Lights 'Linear' means no decay,\n'Inverse' is proportional to the distance from the light,\n'Inverse Square' is proportional to the square of the distance from the light.\nThis is the normal behaviour of light in real world.">Linear,Linear,Inverse,Inverse Square</Attribute>		
	<Attribute Name="Decay_Rate" 					PrettyName="Decay Rate"									Group="'Display Features'"		Type="double"		Description="Control the rate of the Light Falloff."	Min="0.01" Max="1.0">1.0</Attribute>
	<Attribute Name="AmbientOcclusion"				PrettyName="Ambient Occlusion Amount"					Group="'Display Features'"		Type="double"		Description="Control the amount of Ambient Occlusion.\n*Note that you still have to calculate the Ambient Occlusion feature under menu Objects -> Ambient Occlusion."	Min="0.0" Max="1.0">1.0</Attribute>
	<Attribute Name="Render_Passes"					PrettyName="Render Elements"							Group="'Display Features'" 		Type="stringlist"	Description="Shows the contribution of each element separately, Diffuse, Highlights, Reflection, Refraction, Translucency, Self-Illumination,\nor a preview for an average result of the Object Thickness, from dark to light values for thin objects.\nIn Flat Lighting Mode the Render Pass will only display the texture related to the selected pass.\nIn Basic lighting mode it will display texture multiplied by the attribute slider.\nIn Full Shaded lighting mode it will display the end result of all the calculations behind that pass.">Beauty,Beauty,Diffuse,Specular Highlights,Reflection,Refraction,Sub-Surface Scaterring,Self-Illumination,Thickness Map Preview</Attribute>			
	<Attribute Name="Solid"							PrettyName="Thick Glass effect emulation" 				Group="'Display Features'" 		Type="bool"			Description="This is a try to emulate the look in Mari of a Thick/Solid Glass.\nIf not checked it consider the object as a simple slice of glass.\nMari Refraction display some glitches in the Ortho viewport.">false</Attribute>		
  </Attributes>
  <Groups>		
	<Group Name="Displacement"			Expanded="false"></Group>
    <Group Name="'Display Features'"	Expanded="false"></Group>
  </Groups>
  <Tags>
    <Tag>_notcacheable</Tag>
    <Tag>_standalone</Tag>
  </Tags>
    <Contexts>
		<Context Type="NodeGraphView">
            <Inputs>
				<Input Name="View_Current_Channel" Tags='_hidden'><Pos>0,0</Pos></Input>                
				<Input Name="DiffuseColor"><Pos>-300,0</Pos></Input>
				<Input Name="DiffuseSheen"><Pos>-300,-30</Pos></Input>
				<Input Name="Opacity_Map"><Pos>-300,-60</Pos></Input>
				<Input Name="DiffuseRoughness"><Pos>-270,-90</Pos></Input>				
				<Input Name="Incandescence"><Pos>-240,-120</Pos></Input>				
				<Input Name="SpecularColor"><Pos>-200,-150</Pos></Input>				
				<Input Name="HighlightGlossiness"><Pos>-150,-180</Pos></Input>
				<Input Name="ReflectionGlossiness"><Pos>-100,-210</Pos></Input>				
				<Input Name="Anisotropy"><Pos>-40,-240</Pos></Input>
				<Input Name="Rotation"><Pos>0,-270</Pos></Input>
				<Input Name="Vector"><Pos>60,-210</Pos></Input>								
				<Input Name="RefractionColor"><Pos>120,-180</Pos></Input>				
				<Input Name="RefractionGlossiness"><Pos>180,-150</Pos></Input>
				<Input Name="Fog_Color"><Pos>210,-120</Pos></Input>
				<Input Name="Translucency_Color"><Pos>250,-90</Pos></Input>				
				<Input Name="Bump"><Pos>300,-60</Pos></Input>
				<Input Name="Normal"><Pos>300,-30</Pos></Input>
				<Input Name="Displacement"><Pos>300,0</Pos></Input>
				<Input Name="ThicknessMap"><Pos>0,-100</Pos></Input>		
            </Inputs>
        </Context>
        <Context Type="GLSL">
            <Shader ShaderType='Fragment'>
                <Inputs>
                    <Input Name="DiffuseColor"><Default>vec4($DiffuseColor.rgb,-1)</Default></Input>
                    <Input Name="DiffuseSheen"><Default>vec4($DiffuseSheen.rgb,-1)</Default></Input>
					<Input Name="Opacity_Map"><Default>vec4($Opacity_Map.rgb,0)</Default></Input>
                    <Input Name="DiffuseRoughness"><Default>vec4($DiffuseRoughness)</Default></Input>
					<Input Name="Incandescence"><Default>vec4($Incandescence.rgb,-1)</Default></Input>
					<Input Name="SpecularColor"><Default>vec4($SpecularColor.rgb,-1)</Default></Input>
					<Input Name="HighlightGlossiness"><Default>vec4($HighlightGlossiness)</Default></Input>
                    <Input Name="ReflectionGlossiness"><Default>vec4($ReflectionGlossiness)</Default></Input>
					<Input Name="Anisotropy"><Default>vec4($Anisotropy)</Default></Input>
					<Input Name="Vector"><Default>vec4(State.TangentInEyeSpaceFromProjectionCamera.xyz,1)</Default></Input>
					<Input Name="Rotation"><Default>vec4($Rotation)</Default></Input>					
					<Input Name="RefractionColor"><Default>vec4($RefractionColor.rgb,-1)</Default></Input>
                    <Input Name="RefractionGlossiness"><Default>vec4($RefractionGlossiness)</Default></Input>
					<Input Name="Fog_Color"><Default>vec4($Fog_Color.rgb,-1)</Default></Input>
					<Input Name="Translucency_Color"><Default>vec4($Translucency_Color.rgb,-1)</Default></Input>				
					<Input Name="Bump"><Default>vec4(0.5,0.5,0.5,1)</Default></Input>
                    <Input Name="Normal"><Default>vec4(0,0,1,1)</Default></Input>
					<Input Name="Displacement"><Default>vec4(0.5,0.5,0.5,1)</Default></Input>
					<Input Name="ThicknessMap"><Default>vec4(0.5,0.5,0.5,0.0)</Default></Input>
				</Inputs>
				<Body><![CDATA[
	$shadingNode; // Used for continually Mark what shader you are using in case you have renamed the name of the shader inside Mari. This var is also used for the exporter to identify what shader he is picking.
	
	$DiffuseColor;
	$DiffuseSheen;
	$Opacity_Map;
	$DiffuseRoughness;
	$Incandescence;
	$SpecularColor;
	$HighlightGlossiness;
	$ReflectionGlossiness;
	$Anisotropy;
	$Rotation;
	$RefractionColor;
	$RefractionGlossiness;
	$Fog_Color;
	$Translucency_Color;
	
	// These control/input pairs are alpha blended together.
	// If the Channel has an input connected the input is used.	
	// Else the attribute slider is used instead.
	// VAR Name   	  'mix' based on existence of an alpha in the channels
	vec3  difCol 	 = mix( vec3(0),	#DiffuseColor.rgb,			#DiffuseColor.a 		== 0 ? 0 : 1);
	vec3  ShnCol 	 = mix( vec3(0),	#DiffuseSheen.rgb,			#DiffuseSheen.a 		== 0 ? 0 : 1);
	vec3  illumCol 	 = mix( vec3(0), 	#Incandescence.rgb,	 	#Incandescence.a	== 0 ? 0 : 1);
	vec3  reflCol	 = mix( vec3(0),	#SpecularColor.rgb,	 	#SpecularColor.a 		== 0 ? 0 : 1);
	vec3  refrCol 	 = mix( vec3(0),	#RefractionColor.rgb,	 	#RefractionColor.a 		== 0 ? 0 : 1);
	vec3  fogCol 	 = mix( vec3(0),	#Fog_Color.rgb, 		 	#Fog_Color.a  			== 0 ? 0 : 1);
	vec3  transCol 	 = mix( vec3(0),	#Translucency_Color.rgb, 	#Translucency_Color.a  	== 0 ? 0 : 1);
				
	float difrough 	 = mix( float(0),	#DiffuseRoughness.r,		#DiffuseRoughness.a 	== 0 ? 0 : 1);
	float specGloss  = mix( float(0),	#HighlightGlossiness.r,		#HighlightGlossiness.a  == 0 ? 0 : 1);
	float refleGloss = mix( float(0),	#ReflectionGlossiness.r,	#ReflectionGlossiness.a == 0 ? 0 : 1);
	float ani		 = mix( float(0),	#Anisotropy.r,				#Anisotropy.a 			== 0 ? 0 : 1);
	float rot 		 = mix( float(0),	#Rotation.r,				#Rotation.a 			== 0 ? 0 : 1);
	float refraGloss = mix( float(0),	#RefractionGlossiness.r,	#RefractionGlossiness.a == 0 ? 0 : 1);
	
	
	vec3 Current_Channel_Selected = #View_Current_Channel.rgb;
	
	// Check if there's Color painted at the rgb of the Opacity Channels	
	vec3 opacityCol	 = vec3(0,0,0);
	if (color_toValue(#Opacity_Map.rgb) == 0)
	{
		opacityCol = vec3(1.0) - $Opacity_Map.rgb;
	}
	else
	{
		opacityCol = vec3(1.0) - #Opacity_Map.rgb;	
	}	
		
	// The UV Viewport will display what is the Current Channel Selected, unless you don't have any channel. Then it will display the Mari`s alpha checkerboard pattern.	
	if(u_MriViewType==2 || u_MriLightingMode==0)
	{
		// This is the cheapest way to use this "viewbuffer" feature, skipping most of the shader calculation.
		
		Output = #View_Current_Channel;
		
		if($Render_Passes == 1)
		{
			Output.rgb = difCol.rgb;
		}
		if($Render_Passes == 2)
		{
			Output.rgb = ShnCol.rgb;
		}
		if($Render_Passes == 3)
		{
			Output.rgb = reflCol.rgb;
		}
		if($Render_Passes == 4)
		{
			Output.rgb = reflCol.rgb;
		}
		if($Render_Passes == 5)
		{
			Output.rgb = refrCol.rgb;
		}
		if($Render_Passes == 6)
		{
			Output.rgb = transCol.rgb;
		}
		if($Render_Passes == 7)
		{
			Output.rgb = illumCol.rgb;
		}
		if($Render_Passes == 8)
		{
			Output = #ThicknessMap;
		}	
		
		//Display the Thickness imported image in the UV Viewport	
		if(u_MriViewType==2 && $Render_Passes == 8) 
		{
			Output = #ThicknessMap;					
		}	
	
	}
	else
	{
		// ------------  All the shader math ------------
		
		const float PI = 3.14159265358979323846264;
		const float TwoPI = 2.0 * PI;
			
		// View Direction
		vec3 V = normalize(-State.ViewVectorInEyeSpaceFromViewCamera);
		// Normal Direction
		vec3 N = normalize(#Normal.xyz);
			
		float NdotV = dot(N,V);
		// On the wrong side of the face
		if( NdotV <= 0.0)
		{
			N = -N;
			NdotV = 1.0 - NdotV;
		}
		
		
		// Calculates the Space diagonal of the volume inside a cube
		vec3 viewPos = vec3(1.0);
		viewPos.x = mix(1, 2*abs(State.Position.x), abs(State.NormalInEyeSpaceFromViewCamera.x) );
		viewPos.y = mix(1, 2*abs(State.Position.y), abs(State.NormalInEyeSpaceFromViewCamera.y) );
		viewPos.z = mix(1, 2*abs(State.Position.z), abs(State.NormalInEyeSpaceFromViewCamera.z) );
		float base_diagonal = sqrt(viewPos.x*viewPos.x+viewPos.z*viewPos.z);
		float space_diagonal = sqrt(base_diagonal*base_diagonal + viewPos.y*viewPos.y);
			
		// Check if there is a texture assigned to the #ThicknessMap attribute, if does, then use it instead of the 1.5 value. 
		float Thickness = 1.5;	
		if(#ThicknessMap.a > 0)	
		{
			Thickness = 1.0 + #ThicknessMap.r;		
		}
		
		//Use the Baked texture to mix with the multiplication factors of the "Voxelized calculation method" based on depth of the scene
		if(u_MriViewType == 0) //gl buffer does not work well in perspective mode
		{
			//thickness based on position calculation mixed with obj radius
			vec3 P = State.Position*u_MriObjectRadius;
			float d = -dot(State.Position,P);
			float D = abs(d)/length(P);
			D /=u_MriObjectRadius;             
			
			Thickness *= mix( mix(2, 1, 1-NdotV)*u_MriObjectRadius, space_diagonal, (1-NdotV)*length(D));	
		}
		else
		{
			//thickness based on depth and obj radius
			float mult_factor = mix(2*u_MriObjectRadius, u_MriObjectRadius/2, gl_FragDepth);
			//thickness adjusment for the depth based on the Space diagonal of a cube created for each pixel on face.
			float mult_factor2 = mix( mix(space_diagonal, 1, (gl_FragDepth*(1-NdotV))), mix(u_MriObjectRadius, 1, (2*abs(gl_FragDepth - 0.5))*(1-NdotV)), 2*abs(gl_FragDepth - 0.5) )*PI; // this PI is just a adjusment to the color values between the two viewports
			
			Thickness *= mix(mult_factor, mult_factor2, gl_FragDepth);
		}
		
		
			
		float shnNess = color_toValue(ShnCol);
		float shnNess2 = shnNess*shnNess;
		// Roughness/Glossiness attributes squared
		float difrough2 = difrough*difrough;	
		float specGloss2 = specGloss*specGloss;
		float refleGloss2 = refleGloss*refleGloss;	
		// V-ray could lock the highlight specular glossiness to the reflection glossiness attribute.	
		if($Lock_Highlight_Refle_gloss == true)
		{
			specGloss = refleGloss;
			specGloss2 = refleGloss*refleGloss;
		}	
		float refraGloss2 = refraGloss*refraGloss;
		
		
		float _glossiness = 1.0;
		float _Refra_glossiness = 1.0;
		if (abs(ani) != 0)
		{
		if(ani == 0.0 || refleGloss2 == 1.0)  // There is no Anisotropy if the Specular Glossiness = 1.0
			{
				_glossiness = pow( mix( refleGloss, refleGloss2, refleGloss2), mix(1.65+refleGloss2, 2.5+refleGloss2, refleGloss2) );
				_Refra_glossiness = pow( refraGloss, mix(.5, 1.65, refraGloss) );
			}
			else
			{
				_glossiness = pow( mix( refleGloss, refleGloss2, refleGloss), mix(1, 1.5, refleGloss) );
				_Refra_glossiness = pow( refraGloss, mix(.65, 1.5, refraGloss) );			
			}	
		}
		
		// IBL Glossiness adaptation to match the BRDF blur or 'spec lobe' for Environment Lighting
			//_glossiness = pow( mix( refleGloss2, refleGloss, refleGloss), mix(1.15, 2.5, refleGloss) );
			//_Refra_glossiness = pow( refraGloss, 1.5);

		// Fresnel initialization		
		float F = 1.0; 	// used by specular highlights
		float F_refle = 1.0; // used by reflection in environment	

			F = 0.0;
			F_refle = 0.0;	
		
		// Anisotropic coords
		vec3 epsilon = vec3(0, 1, 0.15);
		vec3 X = vec3(1,0,0);
		vec3 Y = vec3(0,1,0);
		if(#Vector.a != 1.0)
		{
			X.x = #Vector.r;
			Y.y = #Vector.g;
		}
		
		
			
		// some display hack for glossiness for anisotropic materials taking into account that our anisotropy is not 100%right, e try to fake a by the look of the glossiness based on what the offline render produce
		float mix_ibl_gloss = 1.0;	
		if(ani >= 0.0)
		{
			if(rot < 0.5)
			{
				epsilon = rot < 0.25 ? mix(X, Y, 4*rot) : mix(Y, -X, 4*(rot-0.25) );
				mix_ibl_gloss = rot < 0.25 ? mix(1, 0, 4*rot) : mix(0, 1, 4*(rot-0.25) );	
			}
			else
			{
				epsilon = rot < 0.75 ? mix(-X, -Y, 4*(rot-0.5)) : mix(-Y, X, 4*(rot-0.75) );
				mix_ibl_gloss = rot < 0.75 ? mix(1, 0, 4*(rot-0.5)) : mix(0, 1, 4*(rot-0.75) );		
			}
			X = normalize(cross(N, epsilon));
			Y = normalize(cross(N, X));
		}		
		else
		{
			if(rot < 0.5)
			{
				epsilon = rot < 0.25 ? mix(Y, -X, 4*rot) : mix(-X, -Y, 4*(rot-0.25) );	
				mix_ibl_gloss = rot < 0.25 ? mix(0, 1, 4*rot) : mix(1, 0, 4*(rot-0.25) );				
			}
			else
			{
				epsilon = rot < 0.75 ? mix(-Y, X, 4*(rot-0.5)) : mix(X, Y, 4*(rot-0.75) );
				mix_ibl_gloss = rot < 0.75 ? mix(0, 1, 4*(rot-0.5)) : mix(1, 0, 4*(rot-0.75) );		
			}
			Y = normalize(cross(N, epsilon));
			X = normalize(cross(N, Y));
		}	

		// Energy variables initialization for each phase of the light calculation
		vec3 EnergyDiffuse = vec3(0.0);	
		vec3 EnergySheen = vec3(0.0);
		vec3 EnergyDiffuse_env = vec3(0.0); //avoid diffuse light bounces from lights to the obj
		vec3 EnergySpecular = vec3(0.0); //also separete the energy from highlights and reflection(point lights and environment light) also avoids lights bouncees from shader to the direct light sourcers the point lights.
		vec3 EnergyReflection_env = vec3(0.0);
		vec3 EnergyRefraction_env = vec3(0.0);
		vec3 EnergySSS = vec3(0.0); 
		vec3 EnergySSS_env = vec3(0.0);
		vec3 EnergyOpacity_env = vec3(0.0);
		
		vec3 LightColour = vec3(0.0);
		float diffterm = 0.0;
		
		float specterm = 0.0;
		float refraterm = 0.0;
		vec3 _Fog_Color = vec3(1.0);	
		float _Fog_bias = 0.0;	
		float Forward_Back_Scat_Color = 0.0;
		
		float _sheeness = 1.0;
		float _sheenessWARD = 1.0;
		float sheen = 0.0;
		_sheeness = pow( mix( shnNess2, shnNess, shnNess), mix(1.15, 2.5, shnNess) );
		_sheenessWARD = pow( mix( shnNess, shnNess2, shnNess2), mix(1.65+shnNess2, 2.5+shnNess2, shnNess2) );
		sheen =  _sheenessWARD - _sheeness;
			
		for(int i=0;i<4;i++)
		{
			if( vec3( 0) == u_MriLightSources[i].DiffuseColor.rgb && vec3( 0) == u_MriLightSources[i].SpecularColor.rgb)
			{
				continue;
			}

			float lightVisibility = mriLightVisibility( i, State.Position);
			
			
			// Light Direction			
			vec3 L = normalize(u_MriLightSources[i].Position.xyz - State.FragmentPositionInEyeSpaceFromViewCamera);
			vec3 LdistP = u_MriLightSources[i].Position.xyz - State.FragmentPositionInEyeSpaceFromViewCamera;	
			
			// Half Vector
			vec3 H = normalize(L+V);		
			
			float LdotN = dot(L,N);
			{			
				// ----------DIFFUSE TERM-----------
				// Oren-Nayar Diffuse Result from the Light Sources
				//diffterm = 1.25*mriBRDF_Oren_Nayar(N, V, L, difrough2);
				diffterm = mriBRDF_Oren_Nayar(N, V, L, difrough2);
				EnergyDiffuse  += (lightVisibility * u_MriLightSources[i].DiffuseColor.rgb) * (diffterm) * att(LdistP, $Light_Falloff, $Decay_Rate);	
				EnergySheen += (lightVisibility * ShnCol.rgb) * (sheen) * att(LdistP, $Light_Falloff, $Decay_Rate);//$$$
							
				// How to calculate fresnel to specular equation, using $IOR from refraction or $Refractive_Index

						F = mriBRDF_Fresnel_Dielectric(L, H, $IOR);
						// *FIX Light Occlusion/Shadow Issue*
						float F0 = (1 - $IOR)/(1 + $IOR);	
						F0 = F0*F0;
						F = mix(F*(1-NdotV), F, F0);	
				// *TWEAK* This is used for energy conservation porpouse because of the fresnel is calculate for each light!
				EnergyDiffuse *= 1.0 - F * color_toValue(reflCol.rgb)*$ReflectionAmount;		
				EnergySheen *= pow(F * color_toValue(reflCol.rgb)*$ReflectionAmount,2);
				
				// ----------Sub-Surface Scattering TERM-----------
				if($SSS_On && color_toValue(refrCol.rgb*fogCol.rgb)*$Fog_multiplier*$RefractionAmount >= 0.01 && color_toValue(fogCol.rgb) < 1.0)
				{
					vec3 Li = vec3(0.0);
					if($Solid)
					{
						Li = normalize( -refract(L, N, (1.0/$IOR)) );
					}
					else
					{
						// Mari Refraction works well in perspective mode, the ortho viewport presents some glitches
						Li = normalize( -refract(L, u_MriViewType == 0 ? N*State.FragmentPositionInEyeSpaceFromViewCamera : N*State.FragmentPositionInNdcSpaceFromProjectionCamera, (1.0/$IOR)) );
					}
					// Calculates the Fog Color based on the thickness of the volume.
					if ($Fog_bias>0.0)
					{
						_Fog_bias = 1.0/(1.0+$Fog_bias);
					}
					if ($Fog_bias <= 0.0)
					{				
						_Fog_bias = 1.0-$Fog_bias;
					}				
					float fdist = pow(Thickness/10, _Fog_bias);				
					_Fog_Color = clamp(pow_RGB(fogCol.rgb, fdist*$Fog_multiplier), 0, 1);
					
					// Fog take energy from Translucency, and translucency gets weaker when refraction is weaker.				
					float SSS = mriBRDF_Oren_Nayar(N, V, Li, $Scatt_coeff) * max(0.0, dot(Li,V));
					float SSS2 = mriBRDF_Oren_Nayar(N, V, Li, $Scatt_coeff) * max(0.0, dot(Li,N)*dot(Li,V));
					EnergySSS += mix(SSS, SSS2, $Fwd_back_coeff) * u_MriLightSources[i].DiffuseColor.rgb * 1.0/fdist * fogCol.rgb * att(LdistP, $Light_Falloff, $Decay_Rate);
					
					// *TWEAK* This is used for energy conservation porpouse because of the fresnel is calculate for each light!
					EnergySSS *= 1.0 - F * color_toValue(reflCol.rgb)*$ReflectionAmount;
					// Fog take energy from Translucency, and translucency gets weaker when refraction is weaker.
					EnergySSS *= (1.0-min(color_toValue(_Fog_Color), 1.0) )*refrCol.rgb*$RefractionAmount;
				}			
				
				// ----------SPECULAR TERM-----------
				// Moved to here so would Avoid shadow issues in the Diffuse Calculation and will prevent future issues in the Specular Calculation.
				if( LdotN > 0.0)
				{
					// How to calculate fresnel to specular equation, using $IOR from refraction or $Refractive_Index

						// Calculate fresnel attenuation for the Diffuse, using the $IOR attributes.					
					
							F = mriBRDF_Fresnel_Dielectric(L, H, $IOR);
														
							specterm = mriBRDF_Blinn(N, H, specGloss2) * F * mriBRDF_Geo_att_Beckmann(N, V, specGloss2)*LdotN/(4*NdotV*LdotN);
						
						// Blinn anisotropy close to Ward Specular				
						if(abs(ani) != 1 && specGloss2 != 1.0)
						{
							float _ani = mix( min(specGloss, 1.0-abs(ani)*specGloss), ani, specGloss-0.0065); //blinns aniso is much more affected and dependent by the spec glossiness
							float ward_specterm = mriBRDF_Ward(N, V, L, H, X, Y, _ani, specGloss-0.0065) * F * mriBRDF_Geo_Att_Ash_Sh00(N, V, L);
							specterm = mix(specterm, ward_specterm, min(1.0, abs(ani)*9) );
						}	
						else
						{
							//If anysotropy vales are -1 or 1, V-ray will render a sharp isotropy highlight.
							specterm = mriBRDF_Ward(N, V, L, H, X, Y, 0, 0.9935) * F * mriBRDF_Geo_Att_Ash_Sh00(N, V, L);	
						}
					EnergySpecular += (lightVisibility * u_MriLightSources[i].SpecularColor.rgb) * (specterm) * att(LdistP, $Light_Falloff, $Decay_Rate);
										
				}	
			}		
		}
		
		if( true == mriEnvironmentLightOn())
		{
			{
				// ----------DIFFUSE TERM-----------
				// Env Light, Light Direction
				vec3 L = N;
				LightColour = mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * L, 0.0);
				// This mix(TwoPI, PI, difrough2) would preserve albedo.	
				EnergyDiffuse_env = mix(1.33*PI, 1.25*PI, difrough2)*mriBRDF_Oren_Nayar(N, V, L, difrough2) * LightColour;
				vec3 Es = 1.0 - mix(1.33*PI, 1.25*PI, shnNess2)*mriBRDF_Oren_Nayar(N, V, L, shnNess2) * LightColour;
				EnergySheen += Es * Es;  //$$$$
			}

			{
				// ----------REFLECTION TERM-----------
				// Env Reflection, Light Direction			
				vec3 L = normalize( -reflect( V, N));
				// Half Vector
				vec3 H = normalize(L+V);         			
				
				float LdotN = dot(L,N);
				// How to calculate fresnel to specular equation, using $IOR from refraction or $Refractive_Index
				
						F_refle = mriBRDF_Fresnel_Dielectric(L, H, $IOR);						
					
				// Diffuse energey conservation from Specular * fresnel.
				EnergyDiffuse_env *= 1.0 - F_refle * color_toValue(reflCol.rgb)*$ReflectionAmount;
				EnergySheen *= 1.0 - color_toValue(ShnCol.rgb) * $ReflectionAmount;
				
				if( 0.0 < LdotN)
				{                
					float lightVisibility = 1.0;
					LightColour = vec3(0.0);
						

						LightColour = lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * L, _glossiness);						
						// Blinn Specular Result from Environment
						specterm = 1.0 * F_refle * mriBRDF_Geo_att_Beckmann(N, V, refleGloss2) * clamp( mix(0.9-LdotN*NdotV/10, 1, refleGloss), 0.0, 1.0 );					

					EnergyReflection_env += specterm * (LightColour);	
				}	

			}			
				
			{
				// ----------REFRACTION TERM-----------
				// Env Refraction, Light Direction			
				// Refraction incoming direction
				vec3 Li = vec3(0.0);
				if($Solid)
				{
					Li = normalize( -refract(V, -N, (1.0/$IOR)) );
				}
				else
				{
					// Mari Refraction works well in perspective mode, the ortho viewport presents some glitches
					Li = normalize( -refract(V, u_MriViewType == 0 ? N*State.FragmentPositionInEyeSpaceFromViewCamera : N*State.FragmentPositionInNdcSpaceFromProjectionCamera, (1.0/$IOR)) );
				}
				
				float lightVisibility = 1.0;
				LightColour = lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * Li, _Refra_glossiness);		
				
				EnergyRefraction_env += (LightColour);		
				// Refraction energey conservation from Specular * fresnel.
				EnergyRefraction_env *= 1.0 - F_refle * color_toValue(reflCol.rgb)*$ReflectionAmount;		
							
				// Calculates the Fog Color based on the thickness of the volume.
				if ($Fog_bias>0.0)
				{
					_Fog_bias = 1.0/(1.0+$Fog_bias);
				}
				if ($Fog_bias <= 0.0)
				{				
					_Fog_bias = 1.0-$Fog_bias;
				}				
				float fdist = pow(Thickness/10, _Fog_bias);				
				_Fog_Color = clamp(pow_RGB(fogCol.rgb, fdist*$Fog_multiplier), 0, 1);						
			}	

			{		
				// ----------Sub-Surface Scattering TERM-----------
				if($SSS_On && color_toValue(refrCol.rgb*fogCol.rgb)*$Fog_multiplier*$RefractionAmount >= 0.01 && color_toValue(fogCol.rgb) < 1.0)
				{
					// Env Light, Light Direction
					// Sub-Surface Scattering
					float lightVisibility = 1.0;				
					vec3 L = normalize( mix(-refract(V, N, 1.0), refract(V, (N*State.FragmentPositionInEyeSpaceFromViewCamera), 1.0)*NdotV, $Fwd_back_coeff) );				
					// Half Vector
					vec3 H = normalize(L+V);			
					
					float LdotN = dot(L,N);
					float LdotH = dot(L,H);
					// Fog Translucency fresnel - go from 1 at normal incidence to .5 at grazing
					// and mix in Fog Translucency retro-reflection based on Fwd_back_coeff
					float FL = mriBRDF_SchlickFresnel(LdotN);
					float FV = mriBRDF_SchlickFresnel(NdotV);			
					float BS_grazingAngle =  mix(.5,mix(0.5,2.5, LdotH*LdotH), mix(1-$Scatt_coeff, $Scatt_coeff, 1-$Fwd_back_coeff) );
					float Back_Scat = mix(1, BS_grazingAngle, FL) * mix(1, BS_grazingAngle, FV);
					
					// FS_grazingAngle used to "flatten" retroreflection based on Scatt_coeff
					float FS_grazingAngle = LdotH*LdotH*(1-$Scatt_coeff);
					float FS = mix(1, FS_grazingAngle, FL) * mix(1, FS_grazingAngle, FV);
					float Foward_Scat = (FS * (1 / (LdotN + NdotV) - .5) + .5);			
				
				
					vec3 _Translucency_Color = transCol.rgb*_Fog_Color;
									
					LightColour = lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * N, mix( BS_grazingAngle, mix(BS_grazingAngle, 0, $Scatt_coeff), color_toValue(_Fog_Color) )*_Refra_glossiness);
									
					Forward_Back_Scat_Color = mix(Foward_Scat, 1.25*Back_Scat, $Fwd_back_coeff)/PI;			
								
					EnergySSS_env += mix( mix(vec3 (0), LightColour*color_toValue(_Translucency_Color), $Fwd_back_coeff), transCol.rgb, color_toValue(_Fog_Color) ) * Forward_Back_Scat_Color; 
					
					EnergySSS_env *= 1.0 - F_refle * color_toValue(reflCol.rgb)*$ReflectionAmount;
					// Fog take energy from Translucency, and translucency gets weaker when refraction is weaker.
					EnergySSS_env *= (1.0-min(color_toValue(_Fog_Color), 1.0) )*refrCol.rgb*$RefractionAmount;
				}				
			}
			
			{
				// ----------OPACITY TERM-----------
				// Env Opacity, Light Direction			
				// Opacity incoming direction
				// It should look like a Ghost with inverted colors!
				vec3 Li = vec3(0.0);
				if($Solid)
				{
					Li = normalize( -refract(V, -N, 1.0) );
				}
				else
				{
					// Mari Refraction works well in perspective mode, the ortho viewport presents some glitches
					Li = normalize( -refract(V, u_MriViewType == 0 ? N*State.FragmentPositionInEyeSpaceFromViewCamera : N*State.FragmentPositionInNdcSpaceFromProjectionCamera, 1.0) );
				}
				float lightVisibility = 1.0;
				LightColour = lightVisibility * mriEnvironmentLight( transpose(mat3(u_MriViewMatrix)) * Li, 1.0);		
				EnergyOpacity_env += LightColour;				
			}
		}
		
		// Energy Conservation, *remeber that we already had taken the specular energy in consideration at each step above!
		float EC_Ke = 1.0 - color_toValue(illumCol.rgb);
		float EC_SSS = 1.0 - color_toValue(transCol.rgb) * Forward_Back_Scat_Color;		
		float EC_Kt = 1.0 - min(1.0-F_refle, 1.0)*color_toValue(refrCol.rgb * _Fog_Color)*$RefractionAmount;
		float EC_Kh = 1.0- color_toValue(ShnCol.rgb)*$RefractionAmount;//1.0 - min(1.0-F_refle, 1.0)*color_toValue(ShnCol.rgb)*$RefractionAmount;
		
		
		// AO option
		float _AO = 1.0 - $AmbientOcclusion * State.AmbientOcclusion;	
		
		vec3 Kd = (EnergyDiffuse + EnergyDiffuse_env * EC_Kt) * difCol.rgb * $DiffuseAmount * ( EC_Ke * EC_SSS ) * _AO;
		//Sheen for cloth-like
		vec3 Kh = EnergySheen * ShnCol.rgb * $ReflectionAmount * ( EC_Ke  ) * _AO ;
		vec3 Ks = EnergySpecular * reflCol.rgb * $ReflectionAmount * ( EC_Ke ) * _AO;	
		vec3 Kr = EnergyReflection_env * reflCol.rgb * $ReflectionAmount * ( EC_Ke ) * _AO;
		vec3 Kt = EnergyRefraction_env * refrCol.rgb * $RefractionAmount * _Fog_Color * ( EC_Ke ) * _AO;
		vec3 Ksss = (EnergySSS + EnergySSS_env * EC_Kt) * transCol.rgb * ( EC_Ke ) * _AO;
		vec3 Opa = EnergyOpacity_env * opacityCol.rgb;		
		
		// New Mari Lighting Mode workflow.
		// Lighting Mode => 0 - "Flat" - only display the Current Channel that is selected.
		// Lighting Mode =>	1 - Basic - Display Diffuse + Sub-surface Scattering
		// Lighting Mode => 2 - Full - Adds the specular/reflection + refraction + self-illumination on top of what the Basic mode displays
		Output.rgb = u_MriLightingMode==0 ? Current_Channel_Selected.rgb : Kd+Ksss;
		Output.rgb += u_MriLightingMode!=2 ? vec3(0.0) : Ks+Kr+Kt+Kh;
		// Self-Illumination
		Output.rgb += u_MriLightingMode==2 ? mix(illumCol.rgb, vec3(0), color_toValue(Kd+Kh)) : vec3(0.0);	
		
		// Opacity
		Output.rgb = u_MriLightingMode==2 ? mix(Opa.rgb, Output.rgb, 1.0-color_toValue(opacityCol.rgb)) : Output.rgb;
		
		// If displaying "flat" lighting mode 0 use the Current Channel alpha.
		Output.a = u_MriLightingMode==0 ? #View_Current_Channel.a : 1.0;		
		
		
		// Render Passes Mode, the beauty pass = 0 doesn't need an if statement, it has coded above and displayed by default
		// Lighting Mode == 1 ? #Channel * $Weight : #Channel * $ChannelWeight * Lighting Contribution
		if($Render_Passes == 1)
		{
			Output.rgb = (u_MriLightingMode==1 ? difCol.rgb * $DiffuseAmount : Kd);
		}
		if($Render_Passes == 2)
		{
			Output.rgb = (u_MriLightingMode==1 ? ShnCol.rgb * $ReflectionAmount : Kh);
		}
		if($Render_Passes == 3)
		{
			Output.rgb = (u_MriLightingMode==1 ? reflCol.rgb * $ReflectionAmount : Ks);
		}
		if($Render_Passes == 4)
		{
			Output.rgb = (u_MriLightingMode==1 ? reflCol.rgb * $ReflectionAmount : Kr);
		}
		if($Render_Passes == 5)
		{
			Output.rgb = (u_MriLightingMode==1 ? refrCol.rgb * $RefractionAmount : Kt);
		}
		if($Render_Passes == 6)
		{
			Output.rgb = (u_MriLightingMode==1 ? transCol.rgb*refrCol.rgb*$RefractionAmount : Ksss);
		}
		if($Render_Passes == 7)
		{
			Output.rgb = mix(illumCol.rgb, vec3(0), color_toValue(Kd));
		}
		if($Render_Passes == 8)
		{
			Output.rgb = vec3(1.0/Thickness);			
		}	
	}	
	            ]]></Body>
            </Shader>			
        </Context>
    </Contexts>
</Node>
